type: edu
files:
  - name: src/numbers/Main.java
    visible: true
    text: |
      package numbers;
      
      public class Main {
          public static void main(String[] args) {
      //        write your code here
          }
      }
    learner_created: false
  - name: test/util/Checker.java
    visible: false
    text: |
      package util;
      
      import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
      
      import java.text.MessageFormat;
      import java.util.function.Predicate;
      import java.util.function.UnaryOperator;
      
      import static java.util.Objects.isNull;
      
      public class Checker implements UnaryOperator<UserProgram> {
          protected Predicate<UserProgram> validator;
          protected String feedback;
          protected Object[] parameters;
      
          protected Checker() {
              this("Incorrect output for user input: {0}.");
          }
      
          protected Checker(String feedback) {
              this($ -> true, feedback);
          }
      
          public Checker(Predicate<UserProgram> validator, String feedback) {
              this.feedback = feedback;
              this.validator = validator;
          }
      
          @Override
          public UserProgram apply(UserProgram program) {
              if (validator.test(program)) {
                  return program;
              }
              throw new WrongAnswer(MessageFormat.format(feedback, isNull(parameters)
                      ? new Object[]{program.getInput(), program.getOutput()} : parameters));
      
          }
      
      }
    learner_created: false
  - name: test/util/LinesChecker.java
    visible: false
    text: |
      package util;
      
      import static java.util.function.Predicate.not;
      
      public class LinesChecker extends Checker {
      
          public LinesChecker(final long expected) {
              super("Expected {0} non blank lines but actual output contains {1} lines.");
      
              validator = program -> {
                  final var actual = program.getOutput().lines().filter(not(String::isBlank)).count();
                  parameters = new Object[]{expected, actual};
                  return actual == expected;
              };
          }
      
      
      }
    learner_created: false
  - name: test/util/RegexChecker.java
    visible: false
    text: |
      package util;
      
      import java.util.regex.Pattern;
      
      public class RegexChecker extends Checker {
          private final Pattern expected;
      
          public RegexChecker(final String regexp, final String feedback) {
              this(regexp, Pattern.CASE_INSENSITIVE, feedback);
          }
      
          public RegexChecker(final String regexp, final int flags, final String feedback) {
              super(feedback);
              this.expected = Pattern.compile(regexp, flags);
              validator = program -> expected.matcher(program.getOutput()).find();
          }
      
      }
    learner_created: false
  - name: test/util/TextChecker.java
    visible: false
    text: |
      package util;
      
      public class TextChecker extends Checker {
      
          public TextChecker(String expected) {
              this(expected, "Expected that the output contains \"{2}\".");
          }
      
          public TextChecker(String expected, String feedback) {
              super(feedback);
      
              validator = program -> {
                  parameters = new Object[]{program.getInput(), program.getOutput(), expected};
                  return program.getOutput().toLowerCase().contains(expected.toLowerCase());
              };
          }
      
      }
    learner_created: false
  - name: test/util/UserProgram.java
    visible: false
    text: |-
      package util;
      
      import org.hyperskill.hstest.testcase.CheckResult;
      import org.hyperskill.hstest.testing.TestedProgram;
      
      import java.util.function.Function;
      
      public class UserProgram {
          private TestedProgram program;
      
          private Object input;
          private String output;
      
          public UserProgram start(String... args) {
              program = new TestedProgram();
              output = program.start(args);
              return this;
          }
      
          public UserProgram check(final Function<UserProgram, UserProgram> checker) {
              return checker.apply(this);
          }
      
          public CheckResult result() {
              return CheckResult.correct();
          }
      
          public UserProgram execute(Object userInput) {
              this.input = userInput;
              output = program.execute(userInput.toString());
              return this;
          }
      
          public String getOutput() {
              return output;
          }
      
          public Object getInput() {
              return input;
          }
      
          public boolean isFinished() {
              return program.isFinished();
          }
      }
    learner_created: false
  - name: test/ListChecker.java
    visible: false
    text: |
      import util.Checker;
      import util.UserProgram;
      
      import java.util.Arrays;
      import java.util.Set;
      import java.util.function.LongPredicate;
      import java.util.function.Predicate;
      import java.util.regex.Pattern;
      import java.util.stream.Collectors;
      import java.util.stream.LongStream;
      
      public class ListChecker extends Checker {
          private static final Pattern LINE_PATTERN = Pattern.compile(
                  "\\s*(?<number>[\\d,. ]*\\d)\\s*(is|:|-)\\s*(?<properties>.+)",
                  Pattern.CASE_INSENSITIVE);
          private static final Pattern NON_DIGIT_SYMBOL = Pattern.compile("\\D");
          private static final Pattern PROPERTIES_SEPARATOR = Pattern.compile("[, ;]+");
      
          private final long expectedCount;
          private final long[] expectedList;
      
          public ListChecker(Request request) {
              this(request.getStart(), request.getCount(), request.getProperties());
          }
      
          public ListChecker(long start, long count) {
              this(start, count, new String[0]);
          }
      
          public ListChecker(long start, long count, String properties) {
              this(start, count, properties.split("[, ]+"));
          }
      
          public ListChecker(long start, long count, String[] queries) {
              super("The list is incorrect");
              this.validator = this::test;
              this.expectedList = getExpectedList(start, count, queries);
              this.expectedCount = count;
          }
      
          private static long[] getExpectedList(long start, long count, String[] queries) {
              final var condition = Arrays.stream(queries).map(query -> {
                  final var isNegative = query.startsWith("-");
                  final var name = isNegative ? query.substring(1) : query;
                  final var property = NumberProperty.valueOf(name.toUpperCase());
                  return isNegative ? property.negate() : property;
              }).reduce(number -> true, LongPredicate::and);
      
              return LongStream
                      .iterate(start, n -> n > 0, n -> n + 1)
                      .filter(condition).limit(count).toArray();
          }
      
          public boolean test(UserProgram program) {
              final var lines = program.getOutput()
                      .lines()
                      .filter(Predicate.not(String::isBlank))
                      .limit(expectedCount)
                      .collect(Collectors.toUnmodifiableList());
      
              if (lines.size() != expectedCount) {
                  return false;
              }
      
              final var iterator = lines.iterator();
              for (final long expectedNumber : expectedList) {
                  final var actualLine = iterator.next();
                  final var matcher = LINE_PATTERN.matcher(actualLine);
                  if (!matcher.matches()) {
                      feedback = "Can''t parse line: \"{0}\". Expected: {1} is ...";
                      parameters = new Object[]{actualLine, expectedNumber};
                      return false;
                  }
      
                  final var rawNumber = matcher.group("number").strip();
                  final var actualNumber = NON_DIGIT_SYMBOL.matcher(rawNumber).replaceAll("");
      
                  if (!String.valueOf(expectedNumber).equals(actualNumber)) {
                      feedback = "Expected number is {0} but actual number is {1}.";
                      parameters = new Object[]{expectedNumber, rawNumber};
                      return false;
                  }
      
                  final var actualProperties = PROPERTIES_SEPARATOR
                          .splitAsStream(matcher.group("properties").toLowerCase())
                          .collect(Collectors.toUnmodifiableList());
      
                  final var expectedProperties = Arrays
                          .stream(NumberProperty.values())
                          .filter(property -> property.test(expectedNumber))
                          .map(Enum::name)
                          .map(String::toLowerCase)
                          .collect(Collectors.toUnmodifiableSet());
      
                  if (actualProperties.size() != expectedProperties.size()) {
                      feedback = "For the number {0} the expected number of properties is {1} but the actual number of properties is {2}. " +
                              "Expected properties are {3}. Actual properties are {4}";
                      parameters = new Object[]{expectedNumber, expectedProperties.size(),
                              actualProperties.size(), expectedProperties, actualProperties};
                      return false;
                  }
      
                  if (!Set.copyOf(actualProperties).equals(expectedProperties)) {
                      feedback = "For the number {0} the expected properties are {1}. The actual properties are {2}.";
                      parameters = new Object[]{expectedNumber, expectedProperties, actualProperties};
                  }
              }
              return true;
          }
      }
    learner_created: false
  - name: test/NumberProperty.java
    visible: false
    text: |
      import java.util.Optional;
      import java.util.function.LongPredicate;
      import java.util.regex.Pattern;
      import java.util.stream.LongStream;
      
      import static java.lang.Character.getNumericValue;
      
      public enum NumberProperty implements LongPredicate {
          EVEN(x -> x % 2 == 0),
          ODD(x -> x % 2 != 0),
          BUZZ(x -> x % 7 == 0 || x % 10 == 7),
          DUCK(number -> digits(number).anyMatch(digit -> digit == 0)),
          PALINDROMIC(number -> {
              final var digits = String.valueOf(number);
              return new StringBuilder(digits).reverse().toString().equals(digits);
          }),
          GAPFUL(number -> number >= 100 &&
                  number % (getNumericValue(String.valueOf(number).charAt(0)) * 10L + number % 10) == 0),
          SPY(x -> digits(x).sum() == digits(x).reduce(1L, (a, b) -> a * b)),
          SQUARE(number -> Math.sqrt(number) % 1 == 0),
          SUNNY(number -> Math.sqrt(number + 1) % 1 == 0),
          JUMPING(number -> {
              for (long previous = number % 10, rest = number / 10; rest > 0; rest /= 10) {
                  long current = rest % 10;
                  long delta = previous - current;
                  if (delta * delta != 1) {
                      return false;
                  }
                  previous = current;
              }
              return true;
          }),
          HAPPY(number -> LongStream.iterate(number, i -> i > 1, NumberProperty::nextHappy).noneMatch(i -> i == 4)),
          SAD(number -> !HAPPY.test(number));
      
          private final LongPredicate hasProperty;
          private final Pattern pattern = Pattern.compile(
                  name() + "\\s*[:-]\\s*(?<value>true|false)",
                  Pattern.CASE_INSENSITIVE
          );
      
          NumberProperty(LongPredicate hasProperty) {
              this.hasProperty = hasProperty;
          }
      
          private static LongStream digits(long number) {
              return Long.toString(number).chars().mapToLong(Character::getNumericValue);
          }
      
          @Override
          public boolean test(long number) {
              return hasProperty.test(number);
          }
      
          public Optional<Boolean> extractValue(String output) {
              final var matcher = pattern.matcher(output);
              final var isFound = matcher.find();
              return Optional
                      .ofNullable(isFound ? matcher.group("value") : null)
                      .map(Boolean::valueOf);
          }
      
          private static long nextHappy(long number) {
              long result = 0;
              for (long i = number; i > 0; i /= 10) {
                  long digit = i % 10;
                  result += digit * digit;
              }
              return result;
          }
      }
    learner_created: false
  - name: test/NumbersTest.java
    visible: false
    text: |
      import org.hyperskill.hstest.dynamic.DynamicTest;
      import org.hyperskill.hstest.stage.StageTest;
      import org.hyperskill.hstest.testcase.CheckResult;
      import util.*;
      
      import java.util.Arrays;
      import java.util.Random;
      import java.util.function.Function;
      import java.util.function.Predicate;
      import java.util.regex.Matcher;
      import java.util.regex.Pattern;
      import java.util.stream.LongStream;
      import java.util.stream.Stream;
      
      public final class NumbersTest extends StageTest {
          private static final Random random = new Random();
      
          private static final int NEGATIVE_NUMBERS_TESTS = 5;
          private static final int FIRST_NUMBERS = 15;
          private static final int RANDOM_TESTS = 10;
          private static final int MAX_PROPERTIES = 5;
          private static final int MAX_COUNT = 20;
          private static final int MIN_START = 2;
      
          private static final Checker WELCOME = new TextChecker("Welcome to Amazing Numbers!");
      
          private static final String EXPLAIN = "The program should explain this in the help.";
          private static final Function<UserProgram, UserProgram> HELP =
                  new TextChecker("Supported requests")
                          .andThen(new RegexChecker(
                                  "(one|a) natural number",
                                  "In this stage, a user can enter one number to print a card. " + EXPLAIN))
                          .andThen(new TextChecker(
                                  "two natural numbers",
                                  "In this stage, a user can enter two numbers to print a list. " + EXPLAIN))
                          .andThen(new TextChecker(
                                  "properties to search for",
                                  "In this stage, a user can enter two numbers and properties to search for. "
                                          + EXPLAIN))
                          .andThen(new TextChecker(
                                  "property preceded by minus",
                                  "In this stage, a user can a minus in front of the property. "
                                          + EXPLAIN))
                          .andThen(new TextChecker(
                                  "enter 0 to exit",
                                  "Display the instructions on how to exit"));
      
          private static final Checker ASK_REQUEST = new TextChecker(
                  "enter a request",
                  "The program should ask a user to enter a request."
          );
          private static final Checker ERROR_FIRST = new RegexChecker(
                  "The first (parameter|number) should be a natural number or zero",
                  "The first parameter \"{0}\" is wrong. The program should print an error message."
          );
          private static final Checker ERROR_SECOND = new RegexChecker(
                  "The second (parameter|number) should be a natural number",
                  "The second parameter \"{0}\" is wrong. The program should print an error message."
          );
          private static final Checker ERROR_PROPERTY = new RegexChecker(
                  "The propert(y|ies) .+ wrong",
                  "The request: \"{0}\" has one wrong property. "
                          + "Expected message: \"The property ... is wrong\"."
          );
          private static final Checker ERROR_PROPERTIES = new RegexChecker(
                  "The propert(y|ies) .+ wrong",
                  "The request: \"{0}\" has two or more incorrect properties. "
                          + "Expected that error message contains: \"The properties ... are wrong\"."
          );
          private static final Checker HELP_PROPERTIES = new TextChecker(
                  "Available properties"
          );
          private static final Checker LIST_PROPERTIES = new Checker(
                  program -> Arrays.stream(NumberProperty.values())
                          .map(Enum::name)
                          .map("(?i)\\b"::concat)
                          .map(Pattern::compile)
                          .map(p -> p.matcher(program.getOutput()))
                          .allMatch(Matcher::find),
                  "If incorrect property has been specified, show the list of the available properties."
          );
          private static final Checker PROPERTIES_OF = new RegexChecker(
                  "properties of \\d",
                  "The first line of number''s properties should contain \"Properties of {0}\"."
          );
          private static final Checker MUTUALLY_EXCLUSIVE = new TextChecker(
                  "The request contains mutually exclusive properties",
                  "The request contains mutually exclusive properties. "
                          + "The program should cancel the request and warn the user."
          );
          private static final Checker RUNNING = new Checker(Predicate.not(UserProgram::isFinished),
                  "The program should continue to work till the user enter \"0\"."
          );
          private static final Checker FINISHED = new Checker(UserProgram::isFinished,
                  "The program should finish when the user entered \"0\"."
          );
          private final UserProgram program = new UserProgram();
      
          private final String[] wrongProperty = new String[]{
                  "1 10 May", "40 2 bay", "37 4 8", "67 2 day", "2 54 Prime", "6 8 ...", "5 9 none"
          };
          private final String[] wrongSecondProperty = new String[]{
                  "1 10 odd girl", "40 2 even day", "37 4 spy 89", "67 2 DUCK +"
          };
          private final String[] wrongTwoProperties = new String[]{
                  "1 10 boy friend", "40 2 long day", "37 4 hot girl", "67 2 strong drake"
          };
          private static final String[] ONE_PROPERTY_WRONG = new String[]{
                  "26534 3 buzz evens palindromic",
                  "4384 2 odd -buzz -palindromic shiny gapful",
                  "1 7 hot sunny odd odd -even",
                  "78343 4 sunny -duck mac odd",
                  "3 4 -even -sunny -hot"
          };
          private final String[] mutuallyExclusive = new String[]{
                  // Stage #6 Two properties
                  "5 1 odd even", "4 3 even odd", "32 2 sunny square", "3153 2 spy duck", "6 7 duck spy",
                  // Stage #7 Several properties
                  "1 2 spy odd sunny even", "7 2 sunny even duck buzz square", "9 5 even spy buzz duck",
                  // Stage #8 Properties preceded by minus
                  "6 6 -odd -even", "6 7 odd -odd", "8 1 -even even", "3 5 odd duck buzz -duck sunny"
          };
          // Stage #3
      
          @DynamicTest(order = 5)
          CheckResult welcomeTest() {
              return program
                      .start()
                      .check(WELCOME)
                      .check(HELP)
                      .check(RUNNING)
                      .check(ASK_REQUEST)
                      .execute(0)
                      .check(FINISHED)
                      .result();
          }
      
          @DynamicTest(repeat = NEGATIVE_NUMBERS_TESTS, order = 10)
          CheckResult notNaturalNumbersTest() {
              long negativeNumber = -random.nextInt(Byte.MAX_VALUE) - 1L;
              return program
                      .start()
                      .check(WELCOME)
                      .check(HELP)
                      .check(ASK_REQUEST)
                      .execute(negativeNumber)
                      .check(ERROR_FIRST)
                      .check(RUNNING)
                      .check(ASK_REQUEST)
                      .execute(0)
                      .check(FINISHED)
                      .result();
          }
      
          @DynamicTest(repeat = RANDOM_TESTS, order = 15)
          CheckResult notNaturalSecondNumberTest() {
              int first = 1 + random.nextInt(Short.MAX_VALUE);
              int negativeSecond = -random.nextInt(Short.MAX_VALUE);
              return program
                      .start()
                      .check(WELCOME)
                      .check(HELP)
                      .check(ASK_REQUEST)
                      .execute(first + " " + negativeSecond)
                      .check(ERROR_SECOND)
                      .check(RUNNING)
                      .check(ASK_REQUEST)
                      .execute(0)
                      .check(FINISHED)
                      .result();
          }
      
          // Stage #4
      
          @DynamicTest(order = 20)
          CheckResult naturalNumbersTest() {
              final var numbers = LongStream.concat(
                      LongStream.range(1, FIRST_NUMBERS),
                      random.longs(RANDOM_TESTS, 1, Long.MAX_VALUE)
              );
      
              program.start().check(WELCOME).check(HELP);
      
              numbers.forEach(number -> program
                      .check(ASK_REQUEST)
                      .execute(number)
                      .check(PROPERTIES_OF)
                      .check(new PropertiesChecker(number))
                      .check(RUNNING));
      
              return program
                      .check(RUNNING)
                      .check(ASK_REQUEST)
                      .execute(0)
                      .check(FINISHED)
                      .result();
          }
      
          @DynamicTest(order = 40)
          CheckResult firstNumbersListTest() {
              return program
                      .start()
                      .check(WELCOME)
                      .check(HELP)
                      .check(ASK_REQUEST)
                      .execute("1 " + FIRST_NUMBERS)
                      .check(new LinesChecker(FIRST_NUMBERS + 1))
                      .check(new ListChecker(1, FIRST_NUMBERS))
                      .execute(0)
                      .check(FINISHED)
                      .result();
          }
      
          private Object[][] getRandomTwo() {
              return random
                      .longs(RANDOM_TESTS, MIN_START, Long.MAX_VALUE - MAX_COUNT)
                      .mapToObj(start -> new Long[]{start, (long) 1 + random.nextInt(MAX_COUNT)})
                      .toArray(Long[][]::new);
          }
      
          // Stage #5
      
          @DynamicTest(data = "getRandomTwo", order = 44)
          CheckResult twoRandomNumbersTest(long start, long count) {
              return program
                      .start()
                      .check(WELCOME)
                      .check(HELP)
                      .check(ASK_REQUEST)
                      .execute(start + " " + count)
                      .check(new LinesChecker(count + 1))
                      .check(new ListChecker(start, count))
                      .check(RUNNING)
                      .execute(0)
                      .check(FINISHED)
                      .result();
          }
      
          @DynamicTest(data = "wrongProperty", order = 50)
          CheckResult wrongPropertyRequestTest(String wrongProperty) {
              return program
                      .start()
                      .check(WELCOME)
                      .check(HELP)
                      .check(ASK_REQUEST)
                      .execute(wrongProperty)
                      .check(ERROR_PROPERTY)
                      .check(HELP_PROPERTIES)
                      .check(LIST_PROPERTIES)
                      .check(RUNNING)
                      .check(ASK_REQUEST)
                      .execute(0)
                      .check(FINISHED)
                      .result();
          }
      
          // The test generates and checks request "1 10 <property>" for each property
      
          @DynamicTest(order = 53)
          CheckResult allPropertiesTest() {
              program.start().check(WELCOME).check(HELP);
      
              Arrays.stream(NumberProperty.values())
                      .map(Enum::name)
                      .map("1 10 "::concat)
                      .map(Request::new)
                      .peek(program.check(ASK_REQUEST)::execute)
                      .forEach(request -> program
                              .check(request.getLinesChecker())
                              .check(new ListChecker(request))
                              .check(RUNNING)
                      );
      
              return program.execute(0).check(FINISHED).result();
          }
      
          // Stage #6
      
          @DynamicTest(repeat = RANDOM_TESTS, order = 55)
          CheckResult randomTwoNumbersAndPropertyTest() {
              final var request = Request.random(Request.Parameter.THREE);
              return program
                      .start()
                      .check(WELCOME)
                      .check(HELP)
                      .check(ASK_REQUEST)
                      .execute(request)
                      .check(request.getLinesChecker())
                      .check(new ListChecker(request))
                      .check(RUNNING)
                      .check(ASK_REQUEST)
                      .execute(0)
                      .check(FINISHED)
                      .result();
          }
      
          @DynamicTest(data = "wrongSecondProperty", order = 60)
          CheckResult wrongSecondPropertyRequestTest(String wrongSecondProperty) {
              return program
                      .start()
                      .check(WELCOME)
                      .check(HELP)
                      .check(ASK_REQUEST)
                      .execute(wrongSecondProperty)
                      .check(ERROR_PROPERTY)
                      .check(HELP_PROPERTIES)
                      .check(LIST_PROPERTIES)
                      .check(RUNNING)
                      .check(ASK_REQUEST)
                      .execute(0)
                      .check(FINISHED)
                      .result();
          }
      
          @DynamicTest(data = "wrongTwoProperties", order = 62)
          CheckResult wrongTwoPropertiesRequestTest(String wrongTwoProperties) {
              return program
                      .start()
                      .check(WELCOME)
                      .check(HELP)
                      .check(ASK_REQUEST)
                      .execute(wrongTwoProperties)
                      .check(ERROR_PROPERTIES)
                      .check(HELP_PROPERTIES)
                      .check(LIST_PROPERTIES)
                      .check(RUNNING)
                      .check(ASK_REQUEST)
                      .execute(0)
                      .check(FINISHED)
                      .result();
          }
      
          private Request[] searchTwoProperties() {
              return Stream.of(
                      "1 7 even spy",
                      "1 10 odd buzz",
                      "1 9 buzz gapful",
                      "1 10 spy buzz",
                      "100000 2 even spy",
                      "100 4 odd gapful",
                      "2000 4 palindromic duck")
                      .map(Request::new)
                      .toArray(Request[]::new);
          }
      
          @DynamicTest(data = "searchTwoProperties", order = 65)
          CheckResult twoNumbersAndTwoPropertyTest(Request request) {
              return program
                      .start()
                      .check(WELCOME)
                      .check(HELP)
                      .check(ASK_REQUEST)
                      .execute(request)
                      .check(request.getLinesChecker())
                      .check(new ListChecker(request))
                      .check(RUNNING)
                      .check(ASK_REQUEST)
                      .execute(0)
                      .check(FINISHED)
                      .result();
          }
      
          // Stage #7
      
          @DynamicTest(data = "ONE_PROPERTY_WRONG", order = 72)
          CheckResult oneWrongPropertyTest(String request) {
              return program
                      .start()
                      .check(WELCOME)
                      .check(HELP)
                      .check(ASK_REQUEST)
                      .execute(request)
                      .check(ERROR_PROPERTY)
                      .check(HELP_PROPERTIES)
                      .check(LIST_PROPERTIES)
                      .check(RUNNING)
                      .check(ASK_REQUEST)
                      .execute(0)
                      .check(FINISHED)
                      .result();
          }
      
          private Request[] getRandomRequests() {
              return Stream.of(
                      "1 7 odd spy palindromic",
                      "1 10 even palindromic duck buzz",
                      "1 9 even palindromic duck buzz gapful",
                      "1 10 even sunny duck buzz gapful",
                      "100000 2 even spy buzz gapful",
                      "100 4 odd spy gapful",
                      "2000 4 even palindromic duck",
                      // Stage #8
                      "1 15 odd spy -duck spy buzz",
                      "1 2 jumping happy -spy"
              )
                      .map(Request::new)
                      .toArray(Request[]::new);
          }
      
          @DynamicTest(data = "getRandomRequests", order = 75)
          CheckResult manyPropertiesTest(Request request) {
              return program
                      .start()
                      .check(WELCOME)
                      .check(HELP)
                      .check(ASK_REQUEST)
                      .execute(request)
                      .check(request.getLinesChecker())
                      .check(new ListChecker(request))
                      .check(RUNNING)
                      .check(ASK_REQUEST)
                      .execute(0)
                      .check(FINISHED)
                      .result();
          }
      
          // Stage #8 If a property is preceded by a minus, this property should not be present in a number
      
          @DynamicTest(data = "mutuallyExclusive", order = 80)
          CheckResult mutuallyExclusivePropertiesTest(String mutuallyExclusive) {
              return program
                      .start()
                      .check(WELCOME)
                      .check(HELP)
                      .check(ASK_REQUEST)
                      .execute(mutuallyExclusive)
                      .check(MUTUALLY_EXCLUSIVE)
                      .check(RUNNING)
                      .check(ASK_REQUEST)
                      .execute(0)
                      .check(FINISHED)
                      .result();
          }
      
          // The test generates and checks request "1 15 -PROPERTY" for all properties
      
          @DynamicTest(order = 85)
          CheckResult allMinusPropertiesTest() {
              program.start().check(WELCOME).check(HELP);
      
              Arrays.stream(NumberProperty.values())
                      .map(Enum::name)
                      .map("1 15 -"::concat)
                      .map(Request::new)
                      .peek(program.check(ASK_REQUEST)::execute)
                      .forEach(request -> program
                              .check(request.getLinesChecker())
                              .check(new ListChecker(request))
                              .check(RUNNING)
                      );
      
              return program.execute(0).check(FINISHED).result();
          }
      
      }
    learner_created: false
  - name: test/PropertiesChecker.java
    visible: false
    text: |
      import util.Checker;
      import util.UserProgram;
      
      public class PropertiesChecker extends Checker {
          private final long number;
      
          public PropertiesChecker(long number) {
              this.number = number;
              validator = this::test;
          }
      
          public boolean test(UserProgram program) {
              for (var property : NumberProperty.values()) {
                  final var name = property.name();
      
                  if (!program.getOutput().toLowerCase().contains(name.toLowerCase())) {
                      feedback = "The property \"{0}\" was not found in the output.";
                      parameters = new Object[]{name};
                      return false;
                  }
      
                  final var expected = property.test(number);
                  final var actualValue = property.extractValue(program.getOutput());
      
                  if (actualValue.isEmpty()) {
                      feedback = "The value for property {0} was not found. Expected: {1}";
                      parameters = new Object[]{name, expected};
                      return false;
                  }
                  final var actual = actualValue.get();
      
                  if (expected != actual) {
                      feedback = "For the property {0}, the expected value is {1} but was found {2}.";
                      parameters = new Object[]{name, expected, actual};
                      return false;
                  }
              }
              return true;
          }
      }
    learner_created: false
  - name: test/Request.java
    visible: false
    text: |
      import util.LinesChecker;
      
      import java.util.Random;
      import java.util.regex.Pattern;
      
      public class Request {
          public static final Pattern PARAMETERS_SEPARATOR = Pattern.compile("\\s+");
          public static final int MAX_COUNT = 20;
          private static final Random random = new Random();
      
          private final String request;
          private final long start;
          private final int count;
          private String[] properties;
      
          public Request(String request) {
              this.request = request;
              var data = PARAMETERS_SEPARATOR.split(request, 3);
              int type = data.length;
              properties = type == 3 ? PARAMETERS_SEPARATOR.split(data[2]) : new String[0];
              count = type > 1 ? Integer.parseInt(data[1]) : 0;
              start = Long.parseLong(data[0]);
          }
      
          public static Request random(Parameter params) {
              final var start = 1 + random.nextInt(Short.MAX_VALUE);
              if (params == Parameter.ONE) {
                  return new Request(String.valueOf(start));
              }
              final var count = 1 + random.nextInt(MAX_COUNT);
              if (params == Parameter.TWO) {
                  return new Request(start + " " + count);
              }
              final var index = random.nextInt(NumberProperty.values().length);
              final var property = NumberProperty.values()[index].name();
              final var request = start + " " + count + " " + property;
              return new Request(request);
          }
      
          public long getStart() {
              return start;
          }
      
          public int getCount() {
              return count;
          }
      
          public String[] getProperties() {
              return properties;
          }
      
          public LinesChecker getLinesChecker() {
              return new LinesChecker(count + 1);
          }
      
          @Override
          public String toString() {
              return request;
          }
      
          enum Parameter {ONE, TWO, THREE}
      }
    learner_created: false
  - name: src/numbers/determiner/GapNumberDeterminer.java
    visible: true
    text: |
      package numbers.determiner;
      
      import numbers.NumberReport;
      
      class GapNumberDeterminer implements NumbersDeterminer {
          @Override
          public boolean getProperty(long number) {
              String strNumber = Long.toString(number);
      
              if (strNumber.length() < 3) return false;
      
              int divider = Integer.parseInt(String.format(
                      "%c%c",
                      strNumber.charAt(0),
                      strNumber.charAt(strNumber.length() - 1)));
              return number % divider == 0;
          }
      
          @Override
          public void setPropertyInReport(NumberReport report) {
              report.setGap(getProperty(report.getNumber()));
          }
      }
    learner_created: true
  - name: src/numbers/determiner/JumpingNumberDeterminer.java
    visible: true
    text: |
      package numbers.determiner;
      
      import numbers.NumberReport;
      
      public class JumpingNumberDeterminer implements NumbersDeterminer {
      
          @Override
          public boolean getProperty(long number) {
              if (number < 10) return true;
              char[] charNumbers = Long.toString(number).toCharArray();
      
              for (int i = 1; i < charNumbers.length; i++) {
                  int previousNumber = Integer.parseInt(String.valueOf(charNumbers[i - 1]));
                  int currentNumber = Integer.parseInt(String.valueOf(charNumbers[i]));
      
                  if (Math.abs(currentNumber - previousNumber) != 1) return false;
              }
              return true;
          }
      
          @Override
          public void setPropertyInReport(NumberReport report) {
              report.setJumping(getProperty(report.getNumber()));
          }
      }
    learner_created: true
  - name: src/numbers/config/GameConfig.java
    visible: true
    text: |
      package numbers.config;
      
      import numbers.filter.Filter;
      import numbers.printer.NumbersPrinter;
      
      import java.util.Collection;
      
      public interface GameConfig {
          void setStartNumber(long number);
          long getStartNumber();
          void setGameMode(GameMode mode);
          GameMode getMode();
          void setRepeats(int repeats);
          int getRepeats();
          void setFilters(Collection<Filter> filters);
          Collection<Filter> getFilters();
      
          void setPrinter(NumbersPrinter printer);
          NumbersPrinter getPrinter();
      }
    learner_created: true
  - name: src/numbers/NumberReport.java
    visible: true
    text: |
      package numbers;
      
      public interface NumberReport {
          long getNumber();
          boolean isEven();
          boolean isBuzz();
          boolean isDuck();
          boolean isPalindromic();
          boolean isGap();
          boolean isSpy();
          boolean isSquare();
          boolean isSunny();
          boolean isJumping();
          void setEven(boolean isEven);
          void setBuzz(boolean isBuzz);
          void setDuck(boolean isDuck);
          void setPalindromic(boolean isPalindromic);
          void setGap(boolean isGap);
          void setSpy(boolean spy);
          void setSunny(boolean isSunny);
          void setSquare(boolean isSquare);
          void setJumping(boolean isJumping);
      }
    learner_created: true
  - name: src/numbers/filter/FilterFactory.java
    visible: true
    text: |
      package numbers.filter;
      
      import numbers.NumberReport;
      
      import java.util.HashMap;
      import java.util.Map;
      
      public class FilterFactory {
          private static final Map<FilterType, Filter> filterCache = new HashMap<>();
      
          public static Filter getFilter(FilterType type) {
              return filterCache.computeIfAbsent(type, FilterFactory::createFilter);
          }
      
          private static Filter createFilter(FilterType type) {
              return switch (type) {
                  case EVEN -> (NumberReport::isEven);
                  case ODD -> (report -> !report.isEven());
                  case BUZZ -> (NumberReport::isBuzz);
                  case DUCK -> (NumberReport::isDuck);
                  case PALINDROMIC -> (NumberReport::isPalindromic);
                  case GAPFUL -> (NumberReport::isGap);
                  case SPY -> (NumberReport::isSpy);
                  case SUNNY -> (NumberReport::isSunny);
                  case SQUARE -> (NumberReport::isSquare);
                  case JUMPING -> (NumberReport::isJumping);
              };
          }
      }
    learner_created: true
  - name: src/numbers/AmazingNumbersGame.java
    visible: true
    text: |
      package numbers;
      
      import numbers.config.GameConfig;
      import numbers.filter.Filter;
      import numbers.printer.NumbersPrinter;
      
      
      public interface AmazingNumbersGame {
      
          void playAmazingNumbers(GameConfig config);
      }
    learner_created: true
  - name: src/numbers/determiner/NumberDeterminerFactory.java
    visible: true
    text: |
      package numbers.determiner;
      
      
      import java.util.Arrays;
      import java.util.Collection;
      import java.util.Set;
      import java.util.stream.Collectors;
      
      public class NumberDeterminerFactory {
      
          public static Collection<NumbersDeterminer> getAllTypes() {
              return Arrays.stream(DeterminerType.values())
                      .map(NumberDeterminerFactory::createNumberDeterminer)
                      .collect(Collectors.toSet());
          }
      
          public enum DeterminerType {
              BUZZ, DUCK, PALINDROMIC, GAP, EVEN, SPY, SUNNY, SQUARE, JUMPING
          }
      
          public static NumbersDeterminer createNumberDeterminer(DeterminerType type) {
              return switch (type) {
                  case BUZZ -> new BuzzNumberDeterminer();
                  case DUCK -> new DuckNumberDeterminer();
                  case PALINDROMIC -> new PalindromicNumberDeterminer();
                  case GAP -> new GapNumberDeterminer();
                  case EVEN -> new EvenDeterminer();
                  case SPY -> new SpyDeterminer();
                  case SQUARE -> new SquareDeterminer();
                  case SUNNY -> new SunnyDeterminer(createNumberDeterminer(DeterminerType.SQUARE));
                  case JUMPING -> new JumpingNumberDeterminer();
              };
          }
      }
    learner_created: true
  - name: src/numbers/determiner/DuckNumberDeterminer.java
    visible: true
    text: |
      package numbers.determiner;
      
      import numbers.NumberReport;
      
      class DuckNumberDeterminer implements NumbersDeterminer {
      
          @Override
          public boolean getProperty(long number) {
              for (char ch : Long.toString(number).toCharArray()) {
                  if (ch == '0') return true;
              }
              return false;
          }
      
          @Override
          public void setPropertyInReport(NumberReport report) {
              report.setDuck(getProperty(report.getNumber()));
          }
      }
    learner_created: true
  - name: src/numbers/AmazingNumberGameImpl.java
    visible: true
    text: |
      package numbers;
      
      import numbers.config.GameConfig;
      import numbers.determiner.NumbersDeterminer;
      import numbers.filter.Filter;
      import numbers.printer.NumbersPrinter;
      
      import java.util.Collection;
      
      public class AmazingNumberGameImpl implements AmazingNumbersGame {
      
          private final Collection<NumbersDeterminer> determiners;
      
          public AmazingNumberGameImpl(Collection<NumbersDeterminer> determiners) {
              this.determiners = determiners;
          }
      
          @Override
          public void playAmazingNumbers(GameConfig config) {
              for (long num = config.getStartNumber(), counter = 0; counter < config.getRepeats(); num++) {
                  NumberReport report = new NumberReportModel(num);
                  for (NumbersDeterminer determiner : determiners) {
                      determiner.setPropertyInReport(report);
                  }
      
                  Collection<Filter> filters = config.getFilters();
                  if (filters != null && !filters.isEmpty()) {
                      boolean continueLoop = false;
                      for (Filter filter : filters) {
                          if (!filter.filter(report)) {
                              continueLoop = true;
                              break;
                          }
                      }
                      if (continueLoop) continue;
                  }
                  counter++;
                  config.getPrinter().print(report);
              }
          }
      }
    learner_created: true
  - name: src/numbers/config/GameMode.java
    visible: true
    text: |
      package numbers.config;
      
      public enum GameMode {
          SINGLE_NUMBER,
          UNFILTERED_SET_OF_NUMBERS,
          FILTERED_SET_OF_NUMBERS
      }
    learner_created: true
  - name: src/numbers/determiner/SpyDeterminer.java
    visible: true
    text: |
      package numbers.determiner;
      
      import numbers.NumberReport;
      
      public class SpyDeterminer implements NumbersDeterminer {
          @Override
          public boolean getProperty(long number) {
              String stringNum = Long.toString(number);
              long sum = 0;
              long mult = 1;
              for (int i = 0; i < stringNum.length(); i++) {
                  sum += Long.parseLong(String.valueOf(stringNum.charAt(i)));
                  mult *= Long.parseLong(String.valueOf(stringNum.charAt(i)));
              }
              return sum == mult;
          }
      
          @Override
          public void setPropertyInReport(NumberReport report) {
              report.setSpy(getProperty(report.getNumber()));
          }
      }
    learner_created: true
  - name: src/numbers/config/GameConfigBuilderImpl.java
    visible: true
    text: |
      package numbers.config;
      
      import numbers.NumberUtils;
      import numbers.exception.InvalidInputException;
      import numbers.filter.Filter;
      import numbers.filter.FilterFactory;
      import numbers.filter.FilterType;
      import numbers.printer.NumbersPrinter;
      import numbers.printer.PrinterFactory;
      
      import java.util.*;
      import java.util.stream.Collectors;
      
      
      public class GameConfigBuilderImpl implements GameConfigBuilder {
      
          private final GameConfig config = new GameConfigModel();
          private final HashMap<FilterType, FilterType> mutiallyExclusiveMap = new HashMap<>() {{
              put(FilterType.EVEN, FilterType.ODD);
              put(FilterType.ODD, FilterType.EVEN);
              put(FilterType.DUCK, FilterType.SPY);
              put(FilterType.SPY, FilterType.DUCK);
              put(FilterType.SUNNY, FilterType.SQUARE);
              put(FilterType.SQUARE, FilterType.SUNNY);
          }};
      
          @Override
          public GameConfig buildConfig(String[] input) throws InvalidInputException {
              if (input == null || input.length == 0) throw new InvalidInputException("Input must exist");
      
              // check command to exit
              if (input[0].equals("0")) return null;
      
              // check if first param is a natural number
              GameMode mode = determineGameMode(input);
              config.setGameMode(mode);
      
              long startNumber = Long.parseLong(input[0]);
              validateFirstArg(startNumber);
      
              NumbersPrinter printer;
              if (mode != GameMode.SINGLE_NUMBER) {
                  printer = PrinterFactory.createPrintStrategy(PrinterFactory.PrinterMode.BRIEF);
                  int repeats = Integer.parseInt(input[1]);
      
                  validateSecondArg(repeats);
                  config.setRepeats(repeats);
      
                  if (mode == GameMode.FILTERED_SET_OF_NUMBERS) {
                      String[] strFilters = Arrays.copyOfRange(input, 2, input.length);
                      Collection<Filter> filters = mapFilters(strFilters);
                      config.setFilters(filters);
                  }
              } else {
                  config.setRepeats(1);
                  printer = PrinterFactory.createPrintStrategy(PrinterFactory.PrinterMode.DETAILED);
              }
      
              config.setPrinter(printer);
              config.setStartNumber(startNumber);
      
              return config;
          }
      
          private Collection<Filter> mapFilters(String[] strFilters) throws InvalidInputException {
              Collection<FilterType> filterTypes = new HashSet<>();
      
              filterTypes = derriveFilterTypes(strFilters);
      
      
              for (FilterType filterType : filterTypes) {
                  if (filterTypes.contains(mutiallyExclusiveMap.get(filterType))) {
                      String msg = String.format(
                              "The request contains mutually exclusive properties: [%s, %s]",
                              filterType, mutiallyExclusiveMap.get(filterType)
                      );
                      throw new InvalidInputException(msg);
                  }
                  filterTypes.add(filterType);
              }
      
              return filterTypes.stream()
                      .map(FilterFactory::getFilter)
                      .collect(Collectors.toSet());
          }
      
          private Collection<FilterType> derriveFilterTypes(String[] strFilters) throws InvalidInputException {
              Collection<String> wrongFilterNames = new HashSet<>();
              Collection<FilterType> filterTypes = new HashSet<>();
              FilterType type;
              // Collect filter types and wrong filter names
              for (String sFilter : strFilters) {
                  try {
                      filterTypes.add(FilterType.valueOf(sFilter.toUpperCase()));
                  } catch (IllegalArgumentException e) {
                      wrongFilterNames.add(sFilter.toUpperCase());
                  }
              }
              // return if all of them are OK
              if (wrongFilterNames.isEmpty()) return filterTypes;
              // if not all of them are OK throw an exception
              String msg = String.format(
                      "The propert%s [%s] %s wrong.\n" +
                              "Available properties: " +
                              "[EVEN, ODD, BUZZ, DUCK, PALINDROMIC, GAPFUL, SPY, SQUARE, SUNNY, JUMPING]%n",
                      wrongFilterNames.size() > 1 ? "ies" : "y",
                      String.join(", ", wrongFilterNames),
                      wrongFilterNames.size() > 1 ? "are" : "is");
              throw new InvalidInputException(msg);
          }
      
          private void validateSecondArg(int repeats) throws InvalidInputException {
              if (!NumberUtils.isNatural(repeats)) {
                  throw new InvalidInputException("The second parameter should be a natural number.");
              }
          }
      
          private void validateFirstArg(long s) throws InvalidInputException {
              if (!NumberUtils.isNatural(s)) {
                  throw new InvalidInputException("\nThe first parameter should be a natural number or zero.");
              }
          }
      
          private static GameMode determineGameMode(String[] input) {
              return switch (input.length) {
                  case 1 -> GameMode.SINGLE_NUMBER;
                  case 2 -> GameMode.UNFILTERED_SET_OF_NUMBERS;
                  default -> GameMode.FILTERED_SET_OF_NUMBERS;
              };
          }
      }
    learner_created: true
  - name: src/numbers/determiner/SquareDeterminer.java
    visible: true
    text: |
      package numbers.determiner;
      
      import numbers.NumberReport;
      
      public class SquareDeterminer implements NumbersDeterminer {
          @Override
          public boolean getProperty(long number) {
              return number % Math.sqrt(number) == 0;
          }
      
          @Override
          public void setPropertyInReport(NumberReport report) {
              report.setSquare(getProperty(report.getNumber()));
          }
      }
    learner_created: true
  - name: src/numbers/determiner/PalindromicNumberDeterminer.java
    visible: true
    text: |
      package numbers.determiner;
      
      import numbers.NumberReport;
      
      class PalindromicNumberDeterminer implements NumbersDeterminer {
          @Override
          public boolean getProperty(long number) {
              String stringNumber = Long.toString(number);
              for (int i = 0; i < stringNumber.length() / 2; i++) {
                  if (stringNumber.charAt(i) != stringNumber.charAt(stringNumber.length() - i - 1)) {
                      return false;
                  }
              }
              return true;
          }
      
          @Override
          public void setPropertyInReport(NumberReport report) {
              report.setPalindromic(getProperty(report.getNumber()));
          }
      }
    learner_created: true
  - name: src/numbers/NumberReportModel.java
    visible: true
    text: |
      package numbers;
      
      public class NumberReportModel implements NumberReport {
      
          private final long number;
          private boolean isEven;
          private boolean isBuzz;
          private boolean isDuck;
          private boolean isPalindromic;
          private boolean isGap;
          private boolean isSpy;
          private boolean isSquare;
          private boolean isSunny;
          private boolean isJumping;
      
          public NumberReportModel(long number) {
              this.number = number;
          }
      
          @Override
          public long getNumber() {
              return this.number;
          }
      
          @Override
          public boolean isEven() {
              return this.isEven;
          }
      
          @Override
          public boolean isBuzz() {
              return this.isBuzz;
          }
      
          @Override
          public boolean isDuck() {
              return this.isDuck;
          }
      
          @Override
          public boolean isPalindromic() {
              return this.isPalindromic;
          }
      
          @Override
          public boolean isGap() {
              return this.isGap;
          }
      
          @Override
          public boolean isSquare() {
              return isSquare;
          }
      
          @Override
          public boolean isSunny() {
              return isSunny;
          }
      
          @Override
          public void setEven(boolean isEven) {
              this.isEven = isEven;
          }
      
          @Override
          public void setBuzz(boolean isBuzz) {
              this.isBuzz = isBuzz;
          }
      
          @Override
          public void setDuck(boolean isDuck) {
              this.isDuck = isDuck;
          }
      
          @Override
          public void setPalindromic(boolean isPalindromic) {
              this.isPalindromic = isPalindromic;
          }
      
          @Override
          public void setGap(boolean isGap) {
              this.isGap = isGap;
          }
      
          @Override
          public boolean isSpy() {
              return this.isSpy;
          }
      
          @Override
          public void setSpy(boolean spy) {
              this.isSpy = spy;
          }
      
          @Override
          public void setSquare(boolean isSquare) {
              this.isSquare = isSquare;
          }
      
          @Override
          public void setSunny(boolean isSunny) {
              this.isSunny = isSunny;
          }
      
          @Override
          public boolean isJumping() {
              return this.isJumping;
          }
      
          @Override
          public void setJumping(boolean isJumping) {
              this.isJumping = isJumping;
          }
      }
    learner_created: true
  - name: src/numbers/filter/Filter.java
    visible: true
    text: |
      package numbers.filter;
      
      import numbers.NumberReport;
      
      @FunctionalInterface
      public interface Filter {
          boolean filter(NumberReport report);
      }
    learner_created: true
  - name: src/numbers/determiner/EvenDeterminer.java
    visible: true
    text: |
      package numbers.determiner;
      
      import numbers.NumberReport;
      import numbers.NumberUtils;
      
      public class EvenDeterminer implements NumbersDeterminer {
          @Override
          public boolean getProperty(long number) {
              return NumberUtils.isEven(number);
          }
      
          @Override
          public void setPropertyInReport(NumberReport report) {
              report.setEven(getProperty(report.getNumber()));
          }
      }
    learner_created: true
  - name: src/numbers/config/GameConfigModel.java
    visible: true
    text: |
      package numbers.config;
      
      import numbers.filter.Filter;
      import numbers.printer.NumbersPrinter;
      
      import java.util.Collection;
      
      public class GameConfigModel implements GameConfig {
      
          private long startNumber;
          private int repeats;
          private GameMode gameMode;
          private Collection<Filter> filters;
          private NumbersPrinter printer;
      
          @Override
          public void setStartNumber(long number) {
              this.startNumber = number;
          }
          @Override
          public long getStartNumber() {
              return this.startNumber;
          }
          @Override
          public void setGameMode(GameMode mode) {
              this.gameMode = mode;
          }
          @Override
          public GameMode getMode() {
              return this.gameMode;
          }
          @Override
          public void setRepeats(int repeats) {
              this.repeats = repeats;
          }
          @Override
          public int getRepeats() {
              return this.repeats;
          }
          @Override
          public void setFilters(Collection<Filter> filters) {
              this.filters = filters;
          }
          @Override
          public Collection<Filter> getFilters() {
              return this.filters;
          }
      
          @Override
          public void setPrinter(NumbersPrinter printer) {
              this.printer = printer;
          }
      
          @Override
          public NumbersPrinter getPrinter() {
              return this.printer;
          }
      }
    learner_created: true
  - name: src/numbers/printer/PrinterFactory.java
    visible: true
    text: |
      package numbers.printer;
      
      public class PrinterFactory {
      
          public enum PrinterMode {
              BRIEF, DETAILED
          }
      
          public static NumbersPrinter createPrintStrategy(PrinterMode mode) {
              return switch (mode) {
                  case BRIEF -> new BriefNumberPrinter();
                  default -> new DetailedNumberPrinter();
              };
          }
      }
    learner_created: true
  - name: src/numbers/config/GameConfigBuilder.java
    visible: true
    text: |
      package numbers.config;
      
      import numbers.exception.InvalidInputException;
      
      public interface GameConfigBuilder {
          GameConfig buildConfig(String[] input) throws InvalidInputException;
      }
    learner_created: true
  - name: src/numbers/filter/FilterType.java
    visible: true
    text: |
      package numbers.filter;
      
      public enum FilterType {
          EVEN, ODD, BUZZ, DUCK, PALINDROMIC, GAPFUL, SPY, SQUARE, SUNNY, JUMPING
      }
    learner_created: true
  - name: src/numbers/printer/NumbersPrinter.java
    visible: true
    text: |
      package numbers.printer;
      
      import numbers.NumberReport;
      
      @FunctionalInterface
      public interface NumbersPrinter {
      
          void print(NumberReport number);
      }
    learner_created: true
  - name: src/numbers/printer/BriefNumberPrinter.java
    visible: true
    text: |
      package numbers.printer;
      
      import numbers.NumberReport;
      import numbers.printer.NumbersPrinter;
      
      public class BriefNumberPrinter implements NumbersPrinter {
          public static final String PATTERN = "             %d is %s%s%s%s%s%s%s%s%s%n";
      
          @Override
          public void print(NumberReport number) {
              System.out.printf(
                      PATTERN,
                      number.getNumber(),
                      number.isBuzz() ? "buzz, " : "",
                      number.isDuck() ? "duck, " : "",
                      number.isPalindromic() ? "palindromic, " : "",
                      number.isGap() ? "gapful, " : "",
                      number.isSpy() ? "spy, " : "",
                      number.isSquare() ? "square, " : "",
                      number.isSunny() ? "sunny, " : "",
                      number.isJumping() ? "jumping, " : "",
                      number.isEven() ? "even" : "odd"
              );
          }
      }
    learner_created: true
  - name: src/numbers/exception/InvalidInputException.java
    visible: true
    text: |
      package numbers.exception;
      
      public class InvalidInputException extends Exception {
          public InvalidInputException(String inputMustExist) {
              super(inputMustExist);
          }
      }
    learner_created: true
  - name: src/numbers/determiner/BuzzNumberDeterminer.java
    visible: true
    text: |
      package numbers.determiner;
      
      import numbers.NumberReport;
      
      class BuzzNumberDeterminer implements NumbersDeterminer {
      
          private final static int DIVISIBLE_CODE = 1;
          private final static int ENDS_WITH_7_CODE = 2;
      
          @Override
          public boolean getProperty(long number) {
              return isBuzz(number);
          }
      
          @Override
          public void setPropertyInReport(NumberReport report) {
              report.setBuzz(getProperty(report.getNumber()));
          }
      
          private boolean isBuzz(long number) {
              int resCode = 0;
              if (number % 7 == 0) {
                  resCode += DIVISIBLE_CODE;
              }
              if ((number - 7) % 10 == 0) {
                  resCode += ENDS_WITH_7_CODE;
              }
              return resCode > 0;
          }
      }
    learner_created: true
  - name: src/numbers/determiner/SunnyDeterminer.java
    visible: true
    text: |
      package numbers.determiner;
      
      import numbers.NumberReport;
      
      public class SunnyDeterminer implements NumbersDeterminer {
      
          private final NumbersDeterminer squareDeterminer;
      
          public SunnyDeterminer(NumbersDeterminer numberDeterminer) {
              this.squareDeterminer = numberDeterminer;
          }
      
          @Override
          public boolean getProperty(long number) {
              return this.squareDeterminer.getProperty(number + 1);
          }
      
          @Override
          public void setPropertyInReport(NumberReport report) {
              report.setSunny(getProperty(report.getNumber()));
          }
      }
    learner_created: true
  - name: src/numbers/determiner/NumbersDeterminer.java
    visible: true
    text: |
      package numbers.determiner;
      
      import numbers.NumberReport;
      
      public interface NumbersDeterminer {
          boolean getProperty(long number);
          void setPropertyInReport(NumberReport report);
      }
    learner_created: true
  - name: src/numbers/printer/DetailedNumberPrinter.java
    visible: true
    text: |
      package numbers.printer;
      
      import numbers.NumberReport;
      
      public class DetailedNumberPrinter implements NumbersPrinter {
      
          private final static String PATTERN = """
                  %nProperties of %d
                                even: %b
                                 odd: %b
                                buzz: %b
                                duck: %b
                         palindromic: %b
                                 spy: %b
                              gapful: %b
                              square: %b
                               sunny: %b
                             jumping: %b%n""";
      
          @Override
          public void print(NumberReport number) {
              System.out.printf(
                      PATTERN,
                      number.getNumber(),
                      number.isEven(),
                      !number.isEven(),
                      number.isBuzz(),
                      number.isDuck(),
                      number.isPalindromic(),
                      number.isSpy(),
                      number.isGap(),
                      number.isSquare(),
                      number.isSunny(),
                      number.isJumping()
              );
          }
      }
    learner_created: true
  - name: src/numbers/NumberUtils.java
    visible: true
    text: |
      package numbers;
      
      public class NumberUtils {
      
          public static boolean isNatural(long number) {
              if (number > 0) {
                  return true;
              }
              return false;
          }
      
          public static boolean isEven(long number) {
              return number % 2 == 0;
          }
      }
    learner_created: true
  - name: src/numbers/determiner/HappyNumberDeterminer.java
    visible: true
    learner_created: true
feedback_link: https://hyperskill.org/projects/184/stages/938/implement#comment
status: Solved
feedback:
  message: Well done! You've finished the project. Select a new project on <a href="https://hyperskill.org/projects">Hyperskill</a>
    to continue learning.
  time: "Sun, 28 Jan 2024 11:28:51 UTC"
record: -1
